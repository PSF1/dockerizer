{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dockerizer Dockerizer is a docker development tool that allows you to run dockerized LAMP projects. Features A centralized proxy. It allows you to run many different projects all under the common 80 and 443 ports instead assigning a por for each project. Out of the box you have https enabled. Configure once and spread to the other collaborators. Commit .docker.env into your project with the required options and your colleagues will just run the same environment with just one command. Forget about the fact that you are working with dockerized projects when run commands. Do you want use gulp or drush from your host machine but execute on the containers? No problem. Dockerizer has the ability to run commands seamlessly. Just run gulp build and that's it.","title":"Home"},{"location":"#dockerizer","text":"Dockerizer is a docker development tool that allows you to run dockerized LAMP projects.","title":"Dockerizer"},{"location":"#features","text":"A centralized proxy. It allows you to run many different projects all under the common 80 and 443 ports instead assigning a por for each project. Out of the box you have https enabled. Configure once and spread to the other collaborators. Commit .docker.env into your project with the required options and your colleagues will just run the same environment with just one command. Forget about the fact that you are working with dockerized projects when run commands. Do you want use gulp or drush from your host machine but execute on the containers? No problem. Dockerizer has the ability to run commands seamlessly. Just run gulp build and that's it.","title":"Features"},{"location":"commands/","text":"Thanks to smartcd (installed when you ran install.sh) you can run common command inside the containers in a transparent way. It is possible because there is a \"bin\" dir with scripts with the same name of the real ones. These scripts just redirect the command into the right container. Currently there're the following common commands: bower Accepts all common software params. bundle Accepts all common software params. compass Accepts all common software params. composer Accepts all common software params. drush Accepts all common software params. drupal (drupal console) Accepts all common software params. gem Accepts all common software params. grunt Accepts all common software params. gulp Accepts all common software params. node Accepts all common software params. npm Accepts all common software params. yarn Accepts all common software params. logs logs shows the logs of all containers or of a specific one. This command can be run anywhere inside the dockerized dir and project. The available options are: -f Follow log output. Usage Show logs of all containers: logs Show logs of an specific container: logs apache , logs php , logs masriadb Show logs of an specific container with the follow option set: logs -f apache cmd cmd allows you to run arbitrary commands like ls , tail inside the container . Use this command when there is no an alias (see \"common commands\"). Usage cmd php ls -l where \"php\" is the container and \"ls -l\" is the sent command. expose expose (Drops a container shell). By default connects to the php container if you do not specify any other. But if you want to connect to another container like the DB one just type expose mariadb . If you want to enter as root just add --root : expose apache --root . Available containers are: php (by default) mariadb (mysql) apache frontend Usage expose drops a shell of php (default) expose apache drops a shell of apache expose apache --root drops a root shell of apache Adding new command To create a new \"command\" like \"drush\" does just create a new empty file at ./bin dir and fill with this code: #!/bin/bash source _command_wrapper '[CONTAINER NAME]' 'exec' '[COMMAND]' $@ CONTAINER NAME: The container where the command resides. COMMAND: the command to be run. And that's all. Now you will be able to run the command locally as any other command and it will be pushed into the right container and run into it.","title":"Available commands"},{"location":"commands/#bower","text":"Accepts all common software params.","title":"bower"},{"location":"commands/#bundle","text":"Accepts all common software params.","title":"bundle"},{"location":"commands/#compass","text":"Accepts all common software params.","title":"compass"},{"location":"commands/#composer","text":"Accepts all common software params.","title":"composer"},{"location":"commands/#drush","text":"Accepts all common software params.","title":"drush"},{"location":"commands/#drupal-drupal-console","text":"Accepts all common software params.","title":"drupal (drupal console)"},{"location":"commands/#gem","text":"Accepts all common software params.","title":"gem"},{"location":"commands/#grunt","text":"Accepts all common software params.","title":"grunt"},{"location":"commands/#gulp","text":"Accepts all common software params.","title":"gulp"},{"location":"commands/#node","text":"Accepts all common software params.","title":"node"},{"location":"commands/#npm","text":"Accepts all common software params.","title":"npm"},{"location":"commands/#yarn","text":"Accepts all common software params.","title":"yarn"},{"location":"commands/#logs","text":"logs shows the logs of all containers or of a specific one. This command can be run anywhere inside the dockerized dir and project. The available options are: -f Follow log output. Usage Show logs of all containers: logs Show logs of an specific container: logs apache , logs php , logs masriadb Show logs of an specific container with the follow option set: logs -f apache","title":"logs"},{"location":"commands/#cmd","text":"cmd allows you to run arbitrary commands like ls , tail inside the container . Use this command when there is no an alias (see \"common commands\"). Usage cmd php ls -l where \"php\" is the container and \"ls -l\" is the sent command.","title":"cmd"},{"location":"commands/#expose","text":"expose (Drops a container shell). By default connects to the php container if you do not specify any other. But if you want to connect to another container like the DB one just type expose mariadb . If you want to enter as root just add --root : expose apache --root . Available containers are: php (by default) mariadb (mysql) apache frontend Usage expose drops a shell of php (default) expose apache drops a shell of apache expose apache --root drops a root shell of apache","title":"expose"},{"location":"commands/#adding-new-command","text":"To create a new \"command\" like \"drush\" does just create a new empty file at ./bin dir and fill with this code: #!/bin/bash source _command_wrapper '[CONTAINER NAME]' 'exec' '[COMMAND]' $@ CONTAINER NAME: The container where the command resides. COMMAND: the command to be run. And that's all. Now you will be able to run the command locally as any other command and it will be pushed into the right container and run into it.","title":"Adding new command"},{"location":"dk/","text":"\"dk\" the dockerizer cli Dockerizer uses a very simple tool to manage the projects. dk new This command will prepare a dockerizer dir for you. For example if you run dk new foo it will create foo dir with the dockerizer structure ready to use. So the only thing you need to do is create web dir as mentioned at Configure a new project on the Install section. dk on projects When you have a configured \"dockerized\" project you will want to start, stop, and restart it right? Well. Just go to the project and run dk start|stop|restart . dk on proxy And what if you want to stop the proxy to release the 80 and 443 ports? Well, run dk stop|start traefik :) (no matter the current path you are on). dk self-update If there is a new version of the dk tool you can easily upgrade it with this command.","title":"dk the dockerizer cli"},{"location":"dk/#dk-the-dockerizer-cli","text":"Dockerizer uses a very simple tool to manage the projects.","title":"\"dk\" the dockerizer cli"},{"location":"dk/#dk-new","text":"This command will prepare a dockerizer dir for you. For example if you run dk new foo it will create foo dir with the dockerizer structure ready to use. So the only thing you need to do is create web dir as mentioned at Configure a new project on the Install section.","title":"dk new"},{"location":"dk/#dk-on-projects","text":"When you have a configured \"dockerized\" project you will want to start, stop, and restart it right? Well. Just go to the project and run dk start|stop|restart .","title":"dk on projects"},{"location":"dk/#dk-on-proxy","text":"And what if you want to stop the proxy to release the 80 and 443 ports? Well, run dk stop|start traefik :) (no matter the current path you are on).","title":"dk on proxy"},{"location":"dk/#dk-self-update","text":"If there is a new version of the dk tool you can easily upgrade it with this command.","title":"dk self-update"},{"location":"dockerenv/","text":".docker.env file This is the shared docker configuration file. On it you can configure things like PHP version, MySQL version, PHP, settings an all you need to fit the project into the docker. VAR MEANING PROJECT_NAME The project base name Needs to be customized PROJECT_BASE_URL The project url Needs to be customized DOCKER_PROJECT_HOST IP of the docker host In order to xdebug you need the right docker host ip. Normally is 172.17.0.1 or 172.17.0.2 PROJECT_BASE_PATH Base project's path If your project resides in a subdir you can specify it on PROJECT_BASE_PATH PHP_MAX_EXECUTION_TIME PHP max execution time PHP_POST_MAX_SIZE PHP max $_POST size PHP_UPLOAD_MAX_FILESIZE PHP max $_POST file size PHP_MEMORY_LIMIT PHP apache memory limit (cli is unlimited) PHP_TAG Sets the php container/version to be used. For linux and mac there are two group of possible values . \"7.1-dev-4.8.0\" format for linux and \"7.2-dev-macos-4.8.0\" for mac. For the rest of available variables please see https://github.com/wodby/docker4drupal Since .docker.env is a common shared file you will not be able to make personal modifications on it like your docker IP since it would be different of your colleague's IP [ DOCKER_PROJECT_HOST ]. For this king of customizations you have .docker.override.env .docker.override.env should be never committed since it is only for you and your environment. The usage is really simple. Just put in there the variables you want to override with the new value like in the original .docker.env file.","title":"The .docker.env file"},{"location":"dockerenv/#dockerenv-file","text":"This is the shared docker configuration file. On it you can configure things like PHP version, MySQL version, PHP, settings an all you need to fit the project into the docker. VAR MEANING PROJECT_NAME The project base name Needs to be customized PROJECT_BASE_URL The project url Needs to be customized DOCKER_PROJECT_HOST IP of the docker host In order to xdebug you need the right docker host ip. Normally is 172.17.0.1 or 172.17.0.2 PROJECT_BASE_PATH Base project's path If your project resides in a subdir you can specify it on PROJECT_BASE_PATH PHP_MAX_EXECUTION_TIME PHP max execution time PHP_POST_MAX_SIZE PHP max $_POST size PHP_UPLOAD_MAX_FILESIZE PHP max $_POST file size PHP_MEMORY_LIMIT PHP apache memory limit (cli is unlimited) PHP_TAG Sets the php container/version to be used. For linux and mac there are two group of possible values . \"7.1-dev-4.8.0\" format for linux and \"7.2-dev-macos-4.8.0\" for mac. For the rest of available variables please see https://github.com/wodby/docker4drupal Since .docker.env is a common shared file you will not be able to make personal modifications on it like your docker IP since it would be different of your colleague's IP [ DOCKER_PROJECT_HOST ]. For this king of customizations you have .docker.override.env .docker.override.env should be never committed since it is only for you and your environment. The usage is really simple. Just put in there the variables you want to override with the new value like in the original .docker.env file.","title":".docker.env file"},{"location":"domains/","text":"Globally available domains localhost:8080 shows you all registered domains for all running projects under dockerizer. Available domains by project Each project will have the following domains (if you configured PROJECT_NAME as \"foo\"): - foo.localhost - Website - foo.pma.localhost - PhpMyAdmin - foo.mailhog.localhost - MailHog client.","title":"Domains"},{"location":"domains/#globally-available-domains","text":"localhost:8080 shows you all registered domains for all running projects under dockerizer.","title":"Globally available domains"},{"location":"domains/#available-domains-by-project","text":"Each project will have the following domains (if you configured PROJECT_NAME as \"foo\"): - foo.localhost - Website - foo.pma.localhost - PhpMyAdmin - foo.mailhog.localhost - MailHog client.","title":"Available domains by project"},{"location":"install/","text":"Installation A brief of what install script will do: Install smartcd if not installed (will be prompted for configuration. Just leave all options by default). Installs a traefik service (at /usr/local/bin/dk_traefik ). Installs dk cli. To install dockerizer run: bash (curl -s https://raw.githubusercontent.com/frontid/dockerizer/master/install.sh) dk start traefik Configure a new project Dockerizer works on a high level of your project and the first step is to clone it on your projects dir: dk new myproject_dockerized cd myproject_dockerized git clone git@github.com:YOU/YOUR-PROJECT.git web Next you need \"dockerize\" a project. To accomplish that the only thing you need to do is create .docker.env and commit the preferences on the file. Dockerizer provides you an example. Copy example.docker.env as .docker.env at your \"web\" dir and configure it (See .docker.env documentation for a more detailed explanation). That's all, now run dk start and happy coding! Run a configured project If your project already has .docker.env pushed on your project follow these steps. dk new myproject_dockerized cd myproject_dockerized git clone git@github.com:YOU/YOUR-PROJECT.git web dk start","title":"Install"},{"location":"install/#installation","text":"A brief of what install script will do: Install smartcd if not installed (will be prompted for configuration. Just leave all options by default). Installs a traefik service (at /usr/local/bin/dk_traefik ). Installs dk cli. To install dockerizer run: bash (curl -s https://raw.githubusercontent.com/frontid/dockerizer/master/install.sh) dk start traefik","title":"Installation"},{"location":"install/#configure-a-new-project","text":"Dockerizer works on a high level of your project and the first step is to clone it on your projects dir: dk new myproject_dockerized cd myproject_dockerized git clone git@github.com:YOU/YOUR-PROJECT.git web Next you need \"dockerize\" a project. To accomplish that the only thing you need to do is create .docker.env and commit the preferences on the file. Dockerizer provides you an example. Copy example.docker.env as .docker.env at your \"web\" dir and configure it (See .docker.env documentation for a more detailed explanation). That's all, now run dk start and happy coding!","title":"Configure a new project"},{"location":"install/#run-a-configured-project","text":"If your project already has .docker.env pushed on your project follow these steps. dk new myproject_dockerized cd myproject_dockerized git clone git@github.com:YOU/YOUR-PROJECT.git web dk start","title":"Run a configured project"},{"location":"mac/","text":"Dockerizer is compatible with mac and out of the box will be almost ready to use. \" Almost \" means that you will need to do a small override since Mac has it own PHP container . Normally on a new or an existent project you will need a .docker.env file configured for your project (See install page instructions) and this file will contain the PHP container the project will use and normally will be a linux version. If all your team is using linux it is ok, but if your team uses mainly Mac then you can select a mac container as a default PHP container (See .docker.env file options for more references). On the other hand, If your team uses linux and you need a mac container for your local development , the way to use a mac version only at your localhost is via .docker.override.env (See .docker.env file options for more references).","title":"Mac"},{"location":"requirements/","text":"All Docker 18.03+ docker-compose git Brew ( Homebrew ) only for mac. Mac For mac you need unison , bash and docker-sync . gem install docker-sync brew install unison brew install bash","title":"Requirements"},{"location":"requirements/#all","text":"Docker 18.03+ docker-compose git Brew ( Homebrew ) only for mac.","title":"All"},{"location":"requirements/#mac","text":"For mac you need unison , bash and docker-sync . gem install docker-sync brew install unison brew install bash","title":"Mac"},{"location":"troubleshoot/","text":"I can't connect to the DB as I was doing it on my localhost Since the DB it's a independent container, the right way to connect to it is point to the remote container like this: 'database' = '[DB_NAME]', 'username' = '[DB_USER]', 'password' = '[DB_PASSWORD]', 'host' = '[PROJECTNAME]_[DB_HOST]', Basically we are using the configured db params at .docker.env . For example if we have a .docker.env configured like this: ... PROJECTNAME=foo DB_NAME=db DB_USER=db DB_PASSWORD=db DB_ROOT_PASSWORD=root DB_HOST=mariadb DB_DRIVER=mysql .... We should connect from our web project using this config: 'database' = 'db', 'username' = 'db', 'password' = 'db', 'host' = 'foo_mariadb', Chrome shows me \"Your connection is not private\" when I try to enter to the https dockerized page. Since dockerizer provides a self signed certificate to allow https localhost development, iy's common to see a warning link this: The solution at chrome is to open a new tab and paste this command: chrome://flags/#allow-insecure-localhost mark the option to \"enabled\" and restart the browser: Now chrome will show the page without prompting you with \"Your connection is not private\" anymore.","title":"Troubleshoot"},{"location":"troubleshoot/#i-cant-connect-to-the-db-as-i-was-doing-it-on-my-localhost","text":"Since the DB it's a independent container, the right way to connect to it is point to the remote container like this: 'database' = '[DB_NAME]', 'username' = '[DB_USER]', 'password' = '[DB_PASSWORD]', 'host' = '[PROJECTNAME]_[DB_HOST]', Basically we are using the configured db params at .docker.env . For example if we have a .docker.env configured like this: ... PROJECTNAME=foo DB_NAME=db DB_USER=db DB_PASSWORD=db DB_ROOT_PASSWORD=root DB_HOST=mariadb DB_DRIVER=mysql .... We should connect from our web project using this config: 'database' = 'db', 'username' = 'db', 'password' = 'db', 'host' = 'foo_mariadb',","title":"I can't connect to the DB as I was doing it on my localhost"},{"location":"troubleshoot/#chrome-shows-me-your-connection-is-not-private-when-i-try-to-enter-to-the-https-dockerized-page","text":"Since dockerizer provides a self signed certificate to allow https localhost development, iy's common to see a warning link this: The solution at chrome is to open a new tab and paste this command: chrome://flags/#allow-insecure-localhost mark the option to \"enabled\" and restart the browser: Now chrome will show the page without prompting you with \"Your connection is not private\" anymore.","title":"Chrome shows me \"Your connection is not private\" when I try to enter to the https dockerized page."},{"location":"uninstall/","text":"If you want to uninstall dockerizer just run this command: bash (curl -s https://raw.githubusercontent.com/frontid/dockerizer/master/uninstall.sh) The script will remove dk, dk_traefik, smartcd and all related stuff. No current docker images and containers of each projects will be removed.","title":"Uninstall"}]}